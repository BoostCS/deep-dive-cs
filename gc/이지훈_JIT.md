## JIT 컴파일러
> JIT 컴파일러는 실행 중에 컴파일을 한다. -> 동적 컴파일

- 기계어로 변환된 코드를 캐시에 저장시켜 재사용시 컴파일을 다시 하지 않아도 되기에 성능이 좋다.
- 런타임에 바이트 코드를 기계어로 변환하는 컴파일을 하면서 이미 캐시에 있는 기계어는 다시 변환하지 않고 사용한다는 의미이다.
- 이러한 캐시를 활용해서 마치 정적 컴파일같은 효과를 낼 수 있다.

### 그럼 모든 코드를 캐시하는가?
- 아쉽게도 그건 불가능하다. JVM의 캐시 공간은 매우 작기 때문이다.
- JVM은 내부에서 자주 수행되는 코드들을 선별하여 캐시 공간에 넣어둔다.
- JIT 컴파일러 내부에는 2가지 컴파일러인 C1 컴파일러와 C2 컴파일러가 존재한다.

==C1 컴파일러==
- 런타임시 바이트 코드를 기계어로 변환하는 과정만 수행한다.

==C2 컴파일러==
- 런타임에 바이트 코드를 기계어로 변환한다음 캐시에 저장하는 과정을 수행한다.

JVM은 코드들의 수행 빈도와 복잡도에 따라 총 4가지 레벨로 분류하여 코드를 수행하며, 이 중 1~3레벨 코드는 C1 컴파일러를 이용해 기계어로 컴파일만 수행하고, 캐싱은 수행하지 않는다.
4레벨에 코드는 C2 컴파일러를 이용해 기계어로 컴파일 뿐만 아니라 캐싱까지 수행하는 것이다.

### 예시를 들어보자!
```kotlin
fun main() { 
	functionA() 
	functionB() 
	functionA() 
	functionA() 
} 
fun functionA() { .. } 
fun functionB() { .. }
```
- functionA가 자주 사용되는 함수라고 판단되면 변환 + 캐시하고 해당 funcationA가 불렸을때 변환하지 않고 캐시에서 가져오게 된다.

```kotlin
fun main() {
	println("hello")
}
```
<img width="706" alt="image" src="https://user-images.githubusercontent.com/53300830/208893750-1dcbf4b1-097b-420f-8d9e-53568bb8223c.png">

> -XX:+PrintCompilation

1번째 열은 타임 스탬프  
2번째 열은 compilation_id 혹은 method_attributed이다.  즉 컴파일ID라고 생각하며 편하다.
3번째 열이 코드 레벨이다! 
- 여기에서  `java.lang.String::charAt` 이 4레벨 코드로 판별이 되면서 C2 컴파일러로 컴파일돼 캐싱된 모습이다.
- 근데 의아한건 무슨 기준으로 얘가 4레벨이라고 판별이 된걸까? 실행된건 1번인데?